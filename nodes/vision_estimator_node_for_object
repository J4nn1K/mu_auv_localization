#!/usr/bin/env python
# DO NOT USE AT THE MOMENT. STILL WORK IN PROGRESS.
import threading

import numpy as np
import rospy
import tf2_geometry_msgs
import tf2_ros
import tf.transformations
from apriltag_ros.msg import AprilTagDetectionArray
from geometry_msgs.msg import PoseStamped, TransformStamped
from hippocampus_common.node import Node
from hippocampus_common.tf_helper import TfHelper
from mu_auv_localization.ekf import ExtendedKalmanFilter


class VisionEstimatorNode(Node):
    def __init__(self):
        super(VisionEstimatorNode, self).__init__("vision_estimator_node_for_object")

        self.lock = threading.Lock()
        self.vehicle_name = self.get_param("vehicle_name")
        if self.vehicle_name is None:
            rospy.logfatal("[%s] No vehicle name specified! Exiting...",
                           rospy.get_name())
            rospy.signal_shutdown("Required vehicle name not specified.")
            exit(1)
        self.t_last_prediction = rospy.get_time()
        self.tf_helper = TfHelper(self.vehicle_name)
        self.tf_buffer = tf2_ros.Buffer()
        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer)
        self.tf_buffer.lookup_transform(target_frame="map_ned",
                                        source_frame="map",
                                        time=rospy.Time(0),
                                        timeout=rospy.Duration(10))
        self.ekf = ExtendedKalmanFilter([0, 0, 0, 0, 0, 0, 1.0, 0, 0, 0])

        self.vision_pose_pub = rospy.Publisher("object_pose", PoseStamped)

        rospy.Subscriber("tag_detections",
                         AprilTagDetectionArray,
                         self.apriltag_callback,
                         queue_size=1)

        self.tf_broadcaster = tf2_ros.TransformBroadcaster()

    def run(self):
        hz = 30.0
        dt = 1.0 / hz
        r = rospy.Rate(hz)

        while not rospy.is_shutdown():
            with self.lock:
                self.ekf.predict(dt, np.array([0, 0, 0]))
                self._publish_pose_estimation()
            r.sleep()

    def apriltag_callback(self, tag_array):
        detection_count = len(tag_array.detections)

        if detection_count:
            transform = self.tf_buffer.lookup_transform(
                target_frame="{}/base_link".format(self.vehicle_name),
                source_frame="object_bundle",
                # target_frame="object_bundle",
                # source_frame="{}/base_link".format(self.vehicle_name),
                time=rospy.Time(0),
                timeout=rospy.Duration(1))
            translation = transform.transform.translation
            quat = transform.transform.rotation
            measurement = np.array([
                translation.x, translation.y, translation.z, quat.x, quat.y,
                quat.z, quat.w
            ]).reshape(-1, 1)

            with self.lock:
                now = rospy.get_time()
                self.ekf.predict(now - self.t_last_prediction,
                                 np.array([0, 0, 0]))
                self.t_last_prediction = now
                self.ekf.update(0.0, measurement)

            self._publish_pose_estimation()

    def _publish_pose_estimation(self):
        estimation = self.ekf._x
        position = estimation[:3]
        orientation = estimation[3:7]
        pose = PoseStamped()
        pose.pose.position.x = position[0]
        pose.pose.position.y = position[1]
        pose.pose.position.z = position[2]
        pose.pose.orientation.x = orientation[0]
        pose.pose.orientation.y = orientation[1]
        pose.pose.orientation.z = orientation[2]
        pose.pose.orientation.w = orientation[3]
        pose.header.stamp = rospy.Time.now()
        pose.header.frame_id = "{}/base_link".format(self.vehicle_name) #"object"
        
        self.vision_pose_pub.publish(pose)

        transform = TransformStamped()
        transform.transform.translation = pose.pose.position
        transform.transform.rotation = pose.pose.orientation
        transform.header = pose.header
        transform.child_frame_id = "object_frame"
        
        self.tf_broadcaster.sendTransform(transform)

def main():
    node = VisionEstimatorNode()
    node.run()


if __name__ == "__main__":
    main()
